\chapter{Individuals in Class Expressions}
\label{chap:nominal}

In this chapter you will:
\begin{enumerate}
\item Use individuals within class expressions;
\item Make classes to find Robert and Richard's parents, ancestors, and so on;
\item Explore equivalence of such classes;
\item Re-visit the closed world.
\end{enumerate}

\snapshot{There is a snapshot of the ontology as required at this point in the tutorial available at \fhkbhome.}

\section{Richard and Robert's Parents and Ancestors}

So far we have only used object properties between unspecified objects. We can, however, specify a specific individual to act at the right-hand-side of a class restriction or type assertion on an individual. The basic syntax for so-called \emph{nominals} is:
\\\\
\owlcode{
Class: ParentOfRobert

	EquivalentTo: Person
		and isParentOf value \irds
}
\\\\
This is an equivalence axiom that recognises any \indiv that is a \person and a parent of \rds.

\steps{Robert and Richards parents}{
\item Create the class \con{ParentOfRobert} as described above;
\item Classify -- inspect where the class is placed in the \fhkb TBox and look at which individuals classify as members of the class;
\item Do the same for a class with the value of \irjs and classify;
\item Finally create a class ParentOfRichardAndRobert, defining it as \con{Person and isParentOf some \{{\irds},{\irjs}\}}; again see what happens on classification. Note that the expressions \texttt{isMotherOf value \irds} and \texttt{isMotherOf some \{\irds\}} are practically identical. The only difference is that using \texttt{value}, you can only specify one individual, while \texttt{some} relates to a class (a set of individuals).
}

We see that these queries work and that we can create more complex nominal based class expressions. The disjunction above is
\\\\
\owlcode{
isParentOf some \{Robert\_David\_Bright\_1965, Richard\_John\_Bright\_1965\}
}
\\\\
The `\{' and `\}' are a bit of syntax that says `here's a class of individual'.

We also see that the classes for the parents of \rds and \rjs have the same members according to the \fhkb, but that the two classes are not inferred to be equivalent. Our domain knowledge indicates the two classes have the same extents (members) and thus the classes are equivalent, but the automated reasoner does not make this inference. As usual, this is because the \fhkb has not given the automated reasoner enough information to make such an inference.

\section{Closing Down What we Know About Parents and Siblings}
\label{sec:nom_owa}

The classes describing the parents of Richard and Robert are not equivalent, even though, as humans, we know their classes of parent are the same. We need more constraints so that it is known that the four parents are the only ones that exist. We can try this by closing down what we know about the immediate family of \rds.

In Chapter~\ref{chap:person} we described that a \person has exactly one \woman and exactly one \man as mother and father (by saying that the \con{hasMother} and \con{hasFather} properties are functional and thus only one of each may be held by any one individual to distinct individuals). The parent properties are defined in terms of \con{hasParent}, \con{hasMother} and \con{hasFather}. The latter two imply \con{hasParent}. The two sub-properties are functional, but there are no constraints on \con{hasParent}, so an individual can hold many instances of this property. So, there is no information in the \fhkb to say a \person has only two parents (we say there is one mother and one father, but not that there are only two parents). Thus Robert and Richard could have other parents and other grandparents than those in the \fhkb; we have to close down our descriptions so that only two parents are possible. There are two ways of doing this:
\begin{enumerate}
\item Using qualified cardinality constraints in a class restriction;
\item Putting a covering axiom on \con{hasParent} in the same way as we did for \con{Sex} in Chapter~\ref{chap:person}.
\end{enumerate}

\steps{Closing the \person class}{
\item Add the restriction \con{hasParent exactly 2 Person} to the class \person;
\item Run the reasoner;
\item Inspect the hierarchy to see where \con{ParentOfRobert} and \con{ParentOfRichard} are placed and whether or not they are found to be equivalent; 
\item Now add the restriction \con{hasParent max 2 Person} to the class \person;
\item Run the reasoner (taking note of how long the reasoning takes) and take another look.

}

We find that these two classes are equivalent; we have supplied enough information to infer that these two classes are equivalent. So, we know that option one above works, but what about option two? \herebedragons
This takes a bit of care to think through, but the  basic thing is to think about how many ways there are to have a \con{hasParent} relationship between two individuals. We know that we can have either a \con{hasFather} or a \con{hasMother} property between two individuals; we also know that we can have only one of each of these properties between an individual and a distinct individual. However, the open world assumption tells us that there may be other ways of having a \con{hasParent} property between two individuals; we've not closed the possibilities. By putting on the \con{hasParent exactly 2 Person} restriction on the \person class, we are effectively closing down the options for ways that a person can have parents; we know because of the functional characteristic on \con{hasMother} and \con{hasFather} that we can have only one of each of these and the two restrictions say that one of each must exist. So, we know we have two ways of having a parent on each \person individual. So, when we say that there are exactly two parents (no more and no less) we have closed down the world of having parents---thus these two classes can be inferred  to be equivalent. It is also worth noting that this extra axiom on the \person class will make the reasoner run much more slowly.

Finally, for option~2, we have no way of placing a covering axiom on a property. What we'd like to be able to state is something like:
\\\\
\owlcode{
ObjectProperty: hasParent

	EquivalentTo: hasFather or hasMother
}
\\
\noindent but we can't.

\section{Summary}
For practice, do the following:
\steps{Additional Practice}{
\item Add lots more classes using members of the ABox as nominals;
\item Make complex expressions using nominals;
\item After each addition of a nominal, classify and see what has been inferred within the \fhkb.
\item See if you can make classes for \con{GrandparentOfRobert} and \con{GrandparentOfRichard} and make them inferred to be equivalent.
}

In this chapter we have seen the use of individuals within class expressions. It allows us to make useful queries and class definitions. The main things to note is that it can be done and that there is some syntax involved. More importantly, some inferences may not be as expected due to the open world assumption in OWL.

\dragon{By now you might have noticed a significant increase in the time the reasoner needs to classify.
Closing down what we know about family relationships takes its toll on the reasoner performance, especially the usage of \con{hasParent exactly 2 Person}. At this point we recommend rewriting this axiom to \con{hasParent max 2 Person}. It gives us most of what we need, but has a little less negative impact on the reasoning time.}
\\

\expressivity{SROIQ}

\ctime{2067273}{529}{147}